## system prompt 和 tool 的职责划分
### System prompt（路由层）
1. 应该做：
    1. 理解用户意图
    2. 决定调用哪个 tool
    3. 提取关键参数给 tool
    4. 组织最终回复
2. 不应该做的
    1. 精确的计算
    2. 复杂业务逻辑校验
    3. 数据格式验证
    4. 状态一致性检查

### tool 的职责
1. 精确的逻辑判断
2. 确定的计算
3. 与外部系统交互
4. 返回结构化结果供 LLM 解读

### tool 的数量
1. 按意图封装，至于实现这个意图需要多少个函数，这是另外一回事
2. 比如 home task 应用，可以考虑将时间检验和创建任务封装成一个 tool，也可以拆成两个
3. 但是如果每个时间规则检验作为一个 tool，可能会让 LLM 产生推理负担，或者同样的任务需要更强的模型才行（待定）

### 定义 tool 的核心原则
1. 按用户意图，而非技术步骤
2. 一个意图一个 tool
3. tool 内部可包含多个步骤（校验、检测冲突、保存）
4. 底层函数在 tool 之间复用
    1. 比如查询任务函数，创建任务 tool 需要它来查询时间段是否冲突
    2. 还可以用来创建 tool 供用户查询任务
5. 不要让 LLM 编排多个细粒度 tool 来完成一个意图。 

## 补充
### 错误处理
1. tool 返回结构化错误，让 LLM 理解，并向用户解释
2. 类似于返回给前端的 JSON 响应体，同时需要在 system prompt 中说明这个结构，方便 LLM 理解 tool 的返回值

### tool 描述
1. 写清楚 tool 的用途和参数，比在 prompt 里面写规则更重要
2. description 是给 LLM 看的说明书，LLM 基于此决定是否调用这个 tool，以及传递什么参数
3. 推荐写法：结构化描述

```plain
适用意图：
- 意图1
- 意图2

功能说明：
- 解析自然语言
- 检测冲突

不适用于：
- 查询任务
```

4. 写作清单
    1. 用户意图示例：列出常见的表达方式，比如提醒我一下、帮我记一下
    2. 功能边界：说明该 tool 能做什么，不能做什么，比如不适用于任务查询
    3. 自动处理：说明 tool 内部会自动处理的事情，比如自动检测任务时间合理性
    4. 参数指导：告诉 LLM 怎么填参数
    5. 关联 tool：指出相关的其他 tool

### 边界情况
1. 简单的判断可以让 LLM 做，比如明显的脏话过滤
2. 涉及精确性的，都交给 tool（代码）

